# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/list.ipynb (unless otherwise specified).

__all__ = ['foldl_list', 'A', 'B', 'foldr_list']

# Cell
from typing import List, TypeVar, Callable, Dict
from dataclasses import dataclass, field


A = TypeVar("A")
B = TypeVar("B")


def foldl_list(a_vals: List[A], start: B, f: Callable[[B, A], B]) -> B:
    """
    Given a way to merge values of `A` with values of `B`, this function
    converts a list of values of type `A` into a single value of type `B`.
    Note that `B` can be the same as the input type (`List[A]`), but it
    need not be.
    """
    out: B = start
    for next_a in a_vals:
        out = f(out, next_a)
    return out

# Cell
def foldr_list(a_vals: List[A], start: B, f: Callable[[A, B], B]) -> B:
    """
    Given a way to merge values of `A` with values of `B`, this function
    converts a list of values of type `A` into a single value of type `B`.
    Note that `B` can be the same as the input type (`List[A]`), but it
    need not be.

    This function is much like `foldl_list`, except that it resolves in the
    reverse order. Note also that `start` plays the role of the output variable
    after the first call.
    """
    if len(a_vals) == 0:
        return start
    else:
        next_a: A
        remaining_a_vals: List[A]
        next_a, *remaining_a_vals = a_vals
        return f(next_a, foldr_list(remaining_a_vals, start, f))