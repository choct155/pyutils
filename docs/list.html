---

title: Generic List Operations

keywords: fastai
sidebar: home_sidebar

summary: "This module houses generic operations on data held in lists."
description: "This module houses generic operations on data held in lists."
nb_path: "nbs/list.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/list.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To start, Python already has the <code>reduce()</code> function in the <code>functools</code> library, but <code>reduce</code> is strictly less powerful than <code>fold</code>) insofar as it is designed to stay within the type boundary. That is, <code>reduce</code> takes a callable of type <code>(A, A) -&gt; A</code>, while <code>fold</code> can break through the type boundary by taking a callable of <code>(B, A) -&gt; B</code>. In some cases, Python's <code>reduce</code> seems to handle this just fine, but it isn't consistent. We can take care of this by forcing the developer to adhere to the contract in <code>fold</code>.</p>
<p><em>Note that Python does not natively support tail call elimination.</em> Consequently, we must be mindful of blowing the stack. The imperative implementations of a normally recursive approach is motivated by this concern.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="foldl_list" class="doc_header"><code>foldl_list</code><a href="__main__.py#L10" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>foldl_list</code>(<strong><code>a_vals</code></strong>:<code>List</code>[<a href="/pyutils/list#A"><code>A</code></a>], <strong><code>start</code></strong>:<a href="/pyutils/list#B"><code>B</code></a>, <strong><code>f</code></strong>:<code>Callable</code>[<a href="/pyutils/list#B"><code>B</code></a>, <a href="/pyutils/list#A"><code>A</code></a>, <a href="/pyutils/list#B"><code>B</code></a>])</p>
</blockquote>
<p>Given a way to merge values of <a href="/pyutils/list#A"><code>A</code></a> with values of <a href="/pyutils/list#B"><code>B</code></a>, this function
converts a list of values of type <a href="/pyutils/list#A"><code>A</code></a> into a single value of type <a href="/pyutils/list#B"><code>B</code></a>.
Note that <a href="/pyutils/list#B"><code>B</code></a> can be the same as the input type (<code>List[A]</code>), but it
need not be.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>fold</code> pattern is quite generic. It can be used to simply add numbers up...</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">xs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">xs_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">foldl_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>
<span class="n">xs_sum</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>10</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">foldl_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">b</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span> <span class="c1"># This actually gets run when we run the test suite</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>... it can also be used to convert data between different type representations.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">even</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">even</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        

<span class="k">def</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">out</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Foo</span><span class="p">]],</span> <span class="n">next_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Foo</span><span class="p">]]:</span>
    <span class="n">f</span><span class="p">:</span> <span class="n">Foo</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">next_i</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">even</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;even&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;even&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="p">]})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;odd&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;odd&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">f</span><span class="p">]})</span>
        
    <span class="k">return</span> <span class="n">out</span>

<span class="n">xs_to_foos</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Foo</span><span class="p">]]</span> <span class="o">=</span> <span class="n">foldl_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;even&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;odd&quot;</span><span class="p">:</span> <span class="p">[]},</span> <span class="n">allocate</span><span class="p">)</span>
<span class="n">xs_to_foos</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>{&#39;even&#39;: [Foo(value=0, even=True),
  Foo(value=2, even=True),
  Foo(value=4, even=True)],
 &#39;odd&#39;: [Foo(value=1, even=False), Foo(value=3, even=False)]}</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As can be seen, the transformation is arbitrary. What makes this pattern powerful is that allows us to focus on a single transformation while <code>fold</code> takes care of traversal.</p>
<p>The <code>l</code> is <a href="/pyutils/list#foldl_list"><code>foldl_list</code></a> indicates that we are <a href="https://superruzafa.github.io/visual-scala-reference/foldLeft/">folding from the left</a>, in the sense that we are updating our output value and carrying forward to the next value in the list. We can also <a href="https://superruzafa.github.io/visual-scala-reference/foldRight/">fold from the right</a>. Effectively, we wait until the last stack frame before resolving any of the calls. It is harder to avoid a recursive approach here, so we should use it with caution.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="foldr_list" class="doc_header"><code>foldr_list</code><a href="https://github.com/choct155/pyutils/tree/master/pyutils/pycollections/list.py#L27" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>foldr_list</code>(<strong><code>a_vals</code></strong>:<code>List</code>[<a href="/pyutils/list#A"><code>A</code></a>], <strong><code>start</code></strong>:<a href="/pyutils/list#B"><code>B</code></a>, <strong><code>f</code></strong>:<code>Callable</code>[<a href="/pyutils/list#A"><code>A</code></a>, <a href="/pyutils/list#B"><code>B</code></a>, <a href="/pyutils/list#B"><code>B</code></a>])</p>
</blockquote>
<p>Given a way to merge values of <a href="/pyutils/list#A"><code>A</code></a> with values of <a href="/pyutils/list#B"><code>B</code></a>, this function
converts a list of values of type <a href="/pyutils/list#A"><code>A</code></a> into a single value of type <a href="/pyutils/list#B"><code>B</code></a>.
Note that <a href="/pyutils/list#B"><code>B</code></a> can be the same as the input type (<code>List[A]</code>), but it
need not be.</p>
<p>This function is much like <a href="/pyutils/list#foldl_list"><code>foldl_list</code></a>, except that it resolves in the
reverse order. Note also that <code>start</code> plays the role of the output variable
after the first call.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/pyutils/list#foldr_list"><code>foldr_list</code></a> is deployed in a very similar fashion to <a href="/pyutils/list#foldl_list"><code>foldl_list</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">xs_sum2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">foldr_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

<span class="n">xs_sum2</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>10</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">foldr_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, there is a difference that is more apparent when order is important. Suppose we wanted to use <code>fold</code> to implement a mapping operating. We can note that folding right will reverse the order unless we go out of our way to prevent it.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">map_left</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">b</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">map_right</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    
<span class="n">foldl_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">[],</span> <span class="n">map_left</span><span class="p">),</span> <span class="n">foldr_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">[],</span> <span class="n">map_right</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>([0, 1, 2, 3, 4], [4, 3, 2, 1, 0])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Given the concern about stack overflows, defaulting to <a href="/pyutils/list#foldl_list"><code>foldl_list</code></a> is a reasonable bias. The onus should be on the developer to demonstrate that <a href="/pyutils/list#foldr_list"><code>foldr_list</code></a> is more appropriate.</p>

</div>
</div>
</div>
</div>
 

